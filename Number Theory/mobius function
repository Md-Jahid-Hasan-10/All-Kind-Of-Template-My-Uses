const int N = 1e6 + 10;
vector<int> primes,isComposite(N + 1, 0);
int mu[N];
void mobius(){
    mu[1] = 1;
    for(int i = 2; i <= N; i++) {
        if(!isComposite[i]) {
            primes.push_back(i);
            mu[i] = -1;
        }
        for(int p : primes) {
            if (1LL * i * p > N) break;
            isComposite[i * p] = 1;
            if (i % p == 0) {
                mu[i * p] = 0;
                break;
            } else {
                mu[i * p] = -mu[i];
            }
        }
    }
}
1-> Number of unordered pairs(i, j) with gcd(a_i, a_j) = 1
freq[x] = how many array elements equal x
cnt[d] = number of array elements divisible by d
pair count = sum{1 to (mx of ar) as d} mu[d] * nCr(cnt[d],2)
subsequence count = sum{1 to mx} mu[d] * (pow(2,cnt[d])-1)
2->How many pair range[1..N] gcd(x,y) = 1
ans = sum{1 to N as d} mu[d]* (N/d)^2
3-> Count Numbers <= N that are divisable by none of primes
L = lcm of all prime.. divs = all divisor of L
ans = sum{divs as d} mu[d]*(N/d)
4-> How many squre free num in [1..N]
count = sum{1 to sqrt(N) as d} mu[d]*(N/(d*d))
5-> how many Lattice point with gcd = 1 or
1 <= x <= n and 1 <= y <= m and gcd(x,y) = 1
ans = sum{1 to min(x,y) as d} mu[d]*(n/d)*(m/d)
