Polygone n point and same distance s
dl area_polygone=(n*s*s)/(4*(tan(PI/n)));
dl redius_polygone = s / (2*sin(PI / n));
glass area = ((pi*h)/3) *((r1*r1)+(r2*r2)+(r1*r2))
struct Point {
    int x, y;
    Point() : x(0), y(0) {}
    Point(int a, int b) : x(a), y(b) {}
};
// Function to calculate the cross product (direction) of vectors (p1p2) and (p1p3)
int direction(const Point &p1, const Point &p2, const Point &p3) {
    return (p2.x - p1.x) * (p3.y - p1.y) - (p2.y - p1.y) * (p3.x - p1.x);
}
// Function to check if point p3 lies on the segment p1p2
bool onsegment(const Point &p1, const Point &p2, const Point &p3) {
    return min(p1.x, p2.x) <= p3.x && p3.x <= max(p1.x, p2.x) &&
           min(p1.y, p2.y) <= p3.y && p3.y <= max(p1.y, p2.y);
}
point vec(point a, point b){
    return {b.x - a.x, b.y - a.y};
}
dl sqnorm(point a){
    return (a.x*a.x + a.y*a.y);
}
dl dot(point a, point b){
    return (a.x*b.x + a.y*b.y);
}
dl angle(point a,point o,point b){
    point oa = vec(o , a), ob = vec(o , b);
    if(sqnorm(oa) == 0 || sqnorm(ob) == 0){
        return 0;
    }
    double alpha = acos(dot(oa, ob) / sqrt(sqnorm(oa) * sqnorm(ob)));
    alpha = alpha * 180 / PI;//angle in degree
    return alpha;// angle of AOB
}
double abs(point a) {
    return sqrt(sqnorm(a));
}
double angle(point a, point b) {
    return acos(dot(a, b) / abs(a) / abs(b));
}
int triArea2(const point &a, const point &b, const point &c) {
    return (a.x*(b.y-c.y) + b.x*(c.y-a.y) + c.x*(a.y-b.y));
}
int sqDist(const point &a, const point &b) {
    return ((a.x-b.x)*(a.x-b.x) + (a.y-b.y)*(a.y-b.y));
}
dl angle(dl a, dl b,dl c){
    dl alpha = acos((b*b-c*c-a*a)/(-2*a*c));
    //alpha = alpha*180.0/PI;//angle (ABC) in degree
    return alpha;
}
dl Slope(Point a, Point b)
{
    if(a.x == b.x && a.y == b.y)return oo;
    double dx = b.x - a.x;
    double dy = b.y - a.y;
    if(dx == 0)return oo;
    return (double)dy / dx;
}
