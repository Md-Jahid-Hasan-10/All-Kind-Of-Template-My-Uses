#include <bits/stdc++.h>
using namespace std;

// Coordinate type (can be int, long double, etc.)
typedef double T;
// epsilon for floating point comparisons
const double EPS = 1e-9; 
// 2D Point structure
struct pt {
    T x, y;

    // Vector arithmetic
    pt operator+(pt p) const { return {x + p.x, y + p.y}; }
    pt operator-(pt p) const { return {x - p.x, y - p.y}; }
    pt operator*(T d)  const { return {x * d, y * d}; }
    pt operator/(T d)  const { return {x / d, y / d}; }
};

// Comparison
bool operator==(pt a, pt b) { return a.x == b.x && a.y == b.y; }
bool operator!=(pt a, pt b) { return !(a == b); }

// Length utilities
T sq(pt p) { return p.x * p.x + p.y * p.y; }   // squared length
double abs(pt p) { return sqrt(sq(p)); }       // actual length (magnitude)

// Dot and Cross Product
T dot(pt a, pt b) { return a.x * b.x + a.y * b.y; }         // dot product
T cross(pt a, pt b) { return a.x * b.y - a.y * b.x; }       // cross product

// Distance between two points
double dist(pt a, pt b) { return abs(a - b); }

// Unit vector (normalize)
pt unit(pt p) { return p / abs(p); }

// Rotate point p around origin by angle 'ang' (in radians)
pt rotate(pt p, double ang) {
    return {p.x * cos(ang) - p.y * sin(ang),
            p.x * sin(ang) + p.y * cos(ang)};
}

// Angle between two vectors
double angle(pt a, pt b) {
    return acos(dot(a, b) / (abs(a) * abs(b)));
}

// Projection of a onto b
pt proj(pt a, pt b) {
    return b * (dot(a, b) / sq(b));
}

// Print nicely
ostream& operator<<(ostream& os, pt p) {
    return os << "(" << p.x << "," << p.y << ")";
}
// --- Line structure ---
struct line {
    pt v; T c;

    // From direction vector v and constant c
    line(pt v, T c) : v(v), c(c) {}

    // From points P and Q
    line(pt p, pt q) { v = q - p; c = cross(v, p); }

    // Returns ax + by - c
    T side(pt p) { return cross(v, p) - c; }

    // Distance from point to line
    double dist(pt p) { return fabs(side(p)) / abs(v); }

    // Translate line by vector t
    line translate(pt t) { return {v, c + cross(v, t)}; }

    // Shift line left/right by distance dist
    line shiftLeft(double dist) { return {v, c + dist * abs(v)}; }
};

// --- Line intersection ---
bool inter(line l1, line l2, pt &out) {
    T d = cross(l1.v, l2.v);
    if (fabs(d) < EPS) return false; // parallel or identical
    out = (l2.v * l1.c - l1.v * l2.c) / d;
    return true;
}
// ---------------- SEGMENT HELPERS ----------------
bool inDisk(pt a, pt b, pt p) { return dot(a - p, b - p) <= EPS; }

bool onSegment(pt a, pt b, pt p) {
    return fabs(cross(b - a, p - a)) < EPS && inDisk(a, b, p);
}

// ---------------- INTERSECTIONS ----------------
bool properInter(pt a, pt b, pt c, pt d, pt &out) {
    double oa = cross(d - c, a - c);
    double ob = cross(d - c, b - c);
    double oc = cross(b - a, c - a);
    double od = cross(b - a, d - a);
    if (oa * ob < 0 && oc * od < 0) {
        out = (a * ob - b * oa) / (ob - oa);
        return true;
    }
    return false;
}
// -- Segment - line distance --
double segPoint(pt a, pt b, pt p) {
    if (a != b) {
        line l(a, b);
        if (dot(b - a, p - a) >= 0 && dot(a - b, p - b) >= 0)
            return l.dist(p);
    }
    return min(abs(p - a), abs(p - b));
}
// Example usage
int main() {
    pt a = {3, 4};
    pt b = {1, 0};
    cout << fixed << setprecision(6);

    cout << "a = " << a << ", b = " << b << "\n";
    cout << "Dot product (a·b): " << dot(a, b) << "\n";
    cout << "Cross product (a×b): " << cross(a, b) << "\n";
    cout << "Distance |a - b|: " << dist(a, b) << "\n";
    cout << "Length of a: " << abs(a) << "\n";
    cout << "Unit vector of a: " << unit(a) << "\n";

    double ang = M_PI / 4; // 45 degrees
    cout << "Rotate a by 45°: " << rotate(a, ang) << "\n";

    cout << "Angle between a and b (radians): " << angle(a, b) << "\n";
    cout << "Projection of a on b: " << proj(a, b) << "\n";

    return 0;
}
