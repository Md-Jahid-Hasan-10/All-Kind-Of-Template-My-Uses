#include <bits/stdc++.h>
using namespace std;

const int N = 200005;
vector<int> adj[N];
int parent[N], depth[N], heavy[N], head[N], pos[N];
int sz[N], arr[N], baseArr[N];
int n, q, curPos;

// -------- SEGMENT TREE (ITERATIVE, MAX) --------
struct SegTree {
    int n;
    vector<long long> seg;
    SegTree(int n = 0) : n(n), seg(2*n, 0LL) {}
    void build() {
        for (int i = n - 1; i > 0; i--)
            seg[i] = max(seg[i<<1], seg[i<<1|1]);
    }
    void update(int p, long long val) {
        p += n;
        seg[p] = val;
        for (p >>= 1; p; p >>= 1)
            seg[p] = max(seg[p<<1], seg[p<<1|1]);
    }
    long long query(int l, int r) {
        long long res = 0;
        for (l += n, r += n; l <= r; l >>= 1, r >>= 1) {
            if (l & 1) res = max(res, seg[l++]);
            if (!(r & 1)) res = max(res, seg[r--]);
        }
        return res;
    }
} seg;

// -------- HLD PART --------
int dfs(int v, int p) {
    parent[v] = p;
    sz[v] = 1;
    heavy[v] = -1;
    int mx = 0;
    for (int u : adj[v]) {
        if (u == p) continue;
        depth[u] = depth[v] + 1;
        dfs(u, v);
        sz[v] += sz[u];
        if (sz[u] > mx) mx = sz[u], heavy[v] = u;
    }
    return sz[v];
}

void decompose(int v, int h) {
    head[v] = h;
    pos[v] = curPos;
    baseArr[curPos++] = arr[v];

    if (heavy[v] != -1)
        decompose(heavy[v], h);

    for (int u : adj[v]) {
        if (u != parent[v] && u != heavy[v])
            decompose(u, u);
    }
}

long long queryPath(int u, int v) {
    long long res = 0;
    while (head[u] != head[v]) {
        if (depth[head[u]] < depth[head[v]])
            swap(u, v);
        res = max(res, seg.query(pos[head[u]], pos[u]));
        u = parent[head[u]];
    }
    if (depth[u] > depth[v])
        swap(u, v);
    res = max(res, seg.query(pos[u], pos[v]));
    return res;
}

// -------- MAIN --------
int main() {
    ios::sync_with_stdio(false);
    cin.tie(nullptr);
    cin >> n >> q;
    for (int i = 1; i <= n; i++) cin >> arr[i];
    for (int i = 1; i < n; i++) {
        int u, v;
        cin >> u >> v;
        adj[u].push_back(v);
        adj[v].push_back(u);
    }
    depth[1] = 0;
    dfs(1, 0);
    curPos = 0;
    decompose(1, 1);
    seg = SegTree(n);
    for (int i = 0; i < n; i++)
        seg.seg[n + i] = baseArr[i];
    seg.build();
    while (q--) {
        int type;
        cin >> type;
        if (type == 1) {
            int node, val;
            cin >> node >> val;
            seg.update(pos[node], val);
        }
        else {
            int u, v;
            cin >> u >> v;
            cout << queryPath(u, v) << " ";
        }
    }
}
